diff --git a/src/web/modules/custom/ps/ps_dictionary/src/Plugin/Field/FieldType/DictionaryItem.php b/src/web/modules/custom/ps/ps_dictionary/src/Plugin/Field/FieldType/DictionaryItem.php
index cd3ec93..98b8f6e 100644
--- a/src/web/modules/custom/ps/ps_dictionary/src/Plugin/Field/FieldType/DictionaryItem.php
+++ b/src/web/modules/custom/ps/ps_dictionary/src/Plugin/Field/FieldType/DictionaryItem.php
@@ -61,9 +61,39 @@ public static function propertyDefinitions(FieldStorageDefinitionInterface $fiel
   public static function defaultStorageSettings(): array {
     return [
       'dictionary_type' => '',
+      // Use callback function for dynamic values from dictionary.
+      'allowed_values_function' => '\Drupal\ps_dictionary\Plugin\Field\FieldType\DictionaryItem::getAllowedValuesCallback',
     ] + parent::defaultStorageSettings();
   }
 
+  /**
+   * Callback to provide allowed values dynamically from dictionary.
+   *
+   * This function is called by options_allowed_values() to populate
+   * the allowed values for this field type.
+   *
+   * @param \Drupal\Core\Field\FieldStorageDefinitionInterface $definition
+   *   The field storage definition.
+   * @param \Drupal\Core\Entity\FieldableEntityInterface|null $entity
+   *   (optional) The entity context.
+   * @param bool $cacheable
+   *   (optional) Whether the values should be cached statically.
+   *
+   * @return array
+   *   An array of allowed values (code => label).
+   */
+  public static function getAllowedValuesCallback(FieldStorageDefinitionInterface $definition, $entity = NULL, &$cacheable = TRUE): array {
+    $dictionary_type = $definition->getSetting('dictionary_type');
+
+    if (!$dictionary_type) {
+      return [];
+    }
+
+    /** @var \Drupal\ps_dictionary\Service\DictionaryManagerInterface $manager */
+    $manager = \Drupal::service('ps_dictionary.manager');
+    return $manager->getOptions($dictionary_type);
+  }
+
   /**
    * {@inheritdoc}
    */
diff --git a/src/web/modules/custom/ps/ps_dictionary/src/Plugin/Field/FieldWidget/DictionarySelectWidget.php b/src/web/modules/custom/ps/ps_dictionary/src/Plugin/Field/FieldWidget/DictionarySelectWidget.php
index 0541af4..1f689a3 100644
--- a/src/web/modules/custom/ps/ps_dictionary/src/Plugin/Field/FieldWidget/DictionarySelectWidget.php
+++ b/src/web/modules/custom/ps/ps_dictionary/src/Plugin/Field/FieldWidget/DictionarySelectWidget.php
@@ -75,33 +75,42 @@ public static function create(ContainerInterface $container, array $configuratio
    * {@inheritdoc}
    */
   public function formElement(FieldItemListInterface $items, $delta, array $element, array &$form, FormStateInterface $form_state): array {
+    // Let parent handle everything - it will use allowed_values_function
+    // automatically via getOptionsProvider().
     $element = parent::formElement($items, $delta, $element, $form, $form_state);
 
-    // Load options from dictionary.
-    // Read from field STORAGE settings (structural), not instance settings.
+    // Add helpful description if dictionary type is not configured.
     $dictionary_type = $this->fieldDefinition
       ->getFieldStorageDefinition()
       ->getSetting('dictionary_type');
-    if ($dictionary_type) {
-      $element['#options'] = $this->dictionaryManager->getOptions($dictionary_type);
+    
+    if (!$dictionary_type) {
+      $element['#description'] = $this->t('Dictionary type not configured. Please configure the field storage settings.');
+    }
 
-      // Add empty option if field is not required.
-      if (!$this->fieldDefinition->isRequired()) {
-        $element['#empty_option'] = $this->t('- None -');
-        $element['#empty_value'] = '';
-      }
+    return $element;
+  }
 
-      // If no options are found, provide a helpful note.
-      if (empty($element['#options'])) {
-        $element['#description'] = $this->t('No entries found for dictionary type @type. Please add entries at /admin/ps/structure/dictionaries/@type/entries.', ['@type' => $dictionary_type]);
+  /**
+   * {@inheritdoc}
+   */
+  public function massageFormValues(array $values, array $form, FormStateInterface $form_state): array {
+    $massaged = parent::massageFormValues($values, $form, $form_state);
+
+    // Fix: parent returns nested array structure [0][0][value] instead of [0][value]
+    // Flatten the structure for single-value fields
+    $fixed = [];
+    foreach ($massaged as $delta => $item) {
+      if (is_array($item) && isset($item[0]) && is_array($item[0])) {
+        // Nested structure - extract the inner array
+        $fixed[$delta] = $item[0];
+      }
+      else {
+        $fixed[$delta] = $item;
       }
-    }
-    else {
-      $element['#options'] = [];
-      $element['#description'] = $this->t('Dictionary type not configured in the field storage settings. Edit the field storage to select a dictionary type.');
     }
 
-    return $element;
+    return $fixed;
   }
 
 }
